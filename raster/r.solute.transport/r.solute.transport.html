<H2>DESCRIPTION</H2>
This numerical program calculates transient
solute transport in porous media in the saturated zone of an aquifer in two dimensions based on
raster maps and the current region resolution.
All initial- and boundary-conditions must be provided as
raster maps.
<br>
<br>
This module calculates the concentration of the solution and optional the
velocity field, based on the hydraulic conductivity, 
the effective porosity and the 
initial piecometric heads. 
The vector components can be visualized with paraview if they are exported
with r.out.vtk.
<br>
<br>
Use <A HREF="r.gwflow.html">r.gwflow</A> to compute the piezometric hights
of the aqufer. The piezometric heights and the hydraulic conductivity
are used to compute the flow direction and the mean velocity of the groundwater.
They are the base of the concentration computation.

<br>
<br>
The solute transport will always be calculated transient. 
If you want to calculate stady state, set the timestep 
to a large number (billions of seconds).
<br>
<br>
To reduce the numerical dispersion you have to use small time steps.
You can choose additionally between full and exponential upwinding to reduce
the numerical dispersion.

<H2>NOTES</H2>
The solute transport partial 
differential equation is of the following form:

<p>
(dc/dt)*R = div ( D grad c - uc) + cs -q/nf(c - c_in)

<ul>
<li>c -- the concentration [kg/m^3]</li>
<li>dt -- the time step for transient calculation in seconds [s]</li>
<li>R -- the linear retardation coefficient [-]</li>
<li>D -- the diffusion and dispersion tensor [m^2/s]</li>
<li>cs -- inner concentration sources/sinks [kg/m^3]</li>
<li>c_in -- the solute concentration of influent water [kg/m^3]</li>
<li>q -- inner well sources/sinks [m^3/s]</li>
<li>nf -- the effective porosity [-] </li>
</ul>

<br>
<br>
Two different boundary conditions are implemented, 
the Dirichlet and Neumann conditions. 
The calculation and boundary status of single cells can be set with the status map, 
the following states are supportet:

<ul>
<li>0 == inactive - the cell with status 0 will not be calulated, active cells will have a no flow boundary to an inactive cell</li>
<li>1 == active - this cell is used for sloute transport calculation, inner sources can be defined for those cells</li>
<li>2 == Dirichlet - cells of this type will have a fixed concentration value which do not change over time </li>
<li>3 == Transmission - cells of this type should be placed on out-flow boundaries to assure the flow of the solute stream out </li>
</ul>

<br>
<br>
Note that all required raster maps are read into main memory. Additionally the
linear equation system will be allocated, so the memory consumption of this
module rapidely grow with the size of the input maps.

<br>
<br>
The solute transport equation can be solved with several solvers.
Several iterative solvers with unsymmetric sparse and quadratic matrices support are implemented.
The jacobi method, the Gauss-Seidel method and the biconjugate gradients-stabilized (bicgstab) method. 
Aditionally a direct Gauss solver and LU solver are available. Those direct solvers
only work with quadratic matrices, so be careful using them with large maps 
(maps of size 10.000 cells will need more than one gigabyte of ram).

<H2>EXAMPLE</H2>
Use this small script to create a working
groundwater flow / solute transport area and data. 
Make sure you are not in a lat/lon projection.

<div class="code"><pre>
#!/usr/bin/env python
# This is an example script how groundwater flow and solute transport are
# computed within grass
import sys
import os
import grass.script as grass

# Overwrite existing maps
grass.run_command("g.gisenv", set="OVERWRITE=1")

grass.message(_("Set the region"))

# The area is 200m x 100m with a cell size of 1m x 1m
grass.run_command("g.region", res=1, res3=1, t=10, b=0, n=100, s=0, w=0, e=200)
grass.run_command("r.mapcalc", expression="phead=if(col() == 1 , 50, 40)")
grass.run_command("r.mapcalc", expression="phead=if(col() ==200  , 45 + row()/40, phead)")
grass.run_command("r.mapcalc", expression="status=if(col() == 1 || col() == 200 , 2, 1)")
grass.run_command("r.mapcalc", expression="well=if((row() == 50 && col() == 175) || (row() == 10 && col() == 135) , -0.001, 0)")
grass.run_command("r.mapcalc", expression="hydcond=0.00005")
grass.run_command("r.mapcalc", expression="recharge=0")
grass.run_command("r.mapcalc", expression="top_conf=20")
grass.run_command("r.mapcalc", expression="top_unconf=60")
grass.run_command("r.mapcalc", expression="bottom=0")
grass.run_command("r.mapcalc", expression="poros=0.17")
grass.run_command("r.mapcalc", expression="syield=0.0001")
grass.run_command("r.mapcalc", expression="null=0.0")

grass.message(_("Compute a steady state groundwater flow"))

grass.run_command("r.gwflow", "s", solver="cg", top="top_conf", bottom="bottom", phead="phead",\
  status="status", hc_x="hydcond", hc_y="hydcond", q="well", s="syield",\
  r="recharge", output="gwresult_conf", dt=8640000000000, type="confined")

grass.message(_("generate the transport data"))
grass.run_command("r.mapcalc", expression="c=if(col() == 15 && row() == 75 , 500.0, 0.0)")
grass.run_command("r.mapcalc", expression="cs=if(col() == 15 && row() == 75 , 0.0, 0.0)")
grass.run_command("r.mapcalc", expression="tstatus=if(col() == 1 || col() == 200 , 3, 1)")
grass.run_command("r.mapcalc", expression="diff=0.0000001")
grass.run_command("r.mapcalc", expression="R=1.0")

# Compute the initial state
grass.run_command("r.solute.transport", "s", solver="bicgstab", top="top_conf",\
  bottom="bottom", phead="gwresult_conf", status="tstatus", hc_x="hydcond", hc_y="hydcond",\
  r="R", cs="cs", q="well", nf="poros", output="stresult_conf_0", dt=3600, diff_x="diff",\
  diff_y="diff", c="c", al=0.1, at=0.01)

# Compute the solute transport for 300 days in 10 day steps
for dt in range(30):
    grass.run_command("r.solute.transport", "s", solver="bicgstab", top="top_conf",\
    bottom="bottom", phead="gwresult_conf", status="tstatus", hc_x="hydcond", hc_y="hydcond",\
    r="R", cs="cs", q="well", nf="poros", output="stresult_conf_" + str(dt + 1), dt=864000, diff_x="diff",\
    diff_y="diff", c="stresult_conf_" + str(dt), al=0.1, at=0.01)


</pre></div>

<H2>SEE ALSO</H2>

<EM><A HREF="r.gwflow.html">r.gwflow</A></EM><br>
<EM><A HREF="r3.gwflow.html">r3.gwflow</A></EM><br>
<EM><A HREF="r.out.vtk.html">r.out.vtk</A></EM><br>

<H2>AUTHOR</H2>
Soeren Gebbert

<p><i>Last changed: $Date: 2007/02/15 23:27:58 $</i>
