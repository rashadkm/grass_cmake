
 DGLIB (Directed Graph Library) aims at giving support to network analysis.
 Each graph is stored in a graph-context structure of type gnGrpGraph_s.
 At any given point in time a graph can be in one of two states: TREE or FLAT.

 Each API function falls into one of the following groups:
 - GRAPH-CONTEXT-MANAGEMENT
 - NODE-MANAGEMENT
 - LINK-MANAGEMENT
 - INPUT-OUTPUT
 - NETWORK-ANALISYS-ALGORITHMS
 - ERROR-REPORTING
 - PROPERTY-HIDERS

 Functions from the NETWORK-ANALISYS-ALGORITHMS and INPUT-OUTPUT groups are only appliable to
 FLAT-state graphs.

 Functions gnGrpAddLink(), gnGrpAddLinkX and gnGrpAddNode() are only appliable to
 TREE-state graphs.


 Functions from the GRAPH-CONTEXT-MANAGEMENT group are used to manage graphs:

    gnGrpInitialize() initializes a new graph structure. After initialization graphs
                      are set to TREE state.
    gnGrpRelease()    releases system resources associated with a graph.
    gnGrpFlatten()    converts a graph from TREE to FLAT state.
    gnGrpUnflatten()  converts a graph from FLAT to TREE.

 
 Functions from the INPUT-OUTPUT group can only work on FLAT state graphs:

    gnGrpRead()  loads a graph from a input file descriptior into a graph structure. The graph
                 structure doesn't need initialization. The graph is set to FLAT state.
    gnGrpWrite() writes a FLAT graph to an output file descriptor. Graphs can only be written in FLAT state.



 API FUNCTION SUMMARY (refer to graph.h for prototype details)

    GRAPH-CONTEXT-MANAGEMENT functions:
 
 int  gnGrpInitialize(...);
 int  gnGrpRelease   (...);
 int  gnGrpUnflatten (...);
 int  gnGrpFlatten   (...);
 void gnGrpResetStats(...);
 
    NODE-MANAGEMENT functions:
 
 int         gnGrpAddNode            (...);
 gnInt32_t * gnGrpGetNode            (...);
 gnInt32_t * gnGrpGetNode_OutLinkarea(...);
 gnInt32_t * gnGrpGetNode_InLinkarea (...);
 gnInt32_t   gnGrpGetNode_Id         (...);
 gnInt32_t   gnGrpGetNode_Status     (...);
 gnInt32_t * gnGrpGetNode_Attr       (...);
 int         gnGrpSetNode_Attr       (...);
 int         gnGrpNodeScan           (...);
 
    LINK-MANAGEMENT functions:
 
 int         gnGrpAddLink            (...);
 int         gnGrpAddLinkX           (...);
 gnInt32_t 	 gnGrpGetOutLink_Count   (...);
 gnInt32_t * gnGrpGetOutLink_ByNode  (...);
 gnInt32_t * gnGrpGetOutLink_ByUserId(...);
 gnInt32_t * gnGrpGetOutLink_ByIndex (...);
 gnInt32_t 	 gnGrpGetInLink_Count    (...);
 gnInt32_t * gnGrpGetInLink_ById     (...);
 gnInt32_t * gnGrpGetInLink_ByUserId (...);
 gnInt32_t * gnGrpGetInLink_ByIndex  (...);
 gnInt32_t   gnGrpGetLink_Cost       (...);
 gnInt32_t   gnGrpGetLink_UserId     (...);
 gnInt32_t * gnGrpGetLink_FromNode   (...);
 gnInt32_t * gnGrpGetLink_ToNode     (...);
 gnInt32_t * gnGrpGetLink_Attr       (...);
 int         gnGrpSetLink_Attr       (...);
 
    INPUT-OUTPUT functions:
 
 int gnGrpWrite(...);
 int gnGrpRead (...);
 
    NETWORK-ANALISYS-ALGORITHMS functions:
 
 gnGrpSPReport_s * gnGrpShortestPath     (...);
 int               gnGrpInitializeSPCache(...);
 void              gnGrpReleaseSPCache   (...);
 void              gnGrpFreeSPReport     (...);
 int               gnGrpDepthSpanning    (...);
 int               gnGrpDepthComponents  (...);
 
    ERROR-REPORTING functions:
 
 int    gnGrpErrno   (...);
 char * gnGrpStrerror(...);
 
    PROPERTY-HIDERS functions:
 
 int         gnGrpGet_Version      (...);
 int         gnGrpGet_Endianess    (...);
 int         gnGrpGet_NodeAttrSize (...);
 int         gnGrpGet_LinkAttrSize (...);
 int         gnGrpGet_NodeCount    (...);
 int         gnGrpGet_FromNodeCount(...);
 int         gnGrpGet_ToNodeCount  (...);
 int         gnGrpGet_LinkCount    (...);
 int         gnGrpGet_GraphState   (...);
 gnInt32_t * gnGrpGet_Opaque	   (...);
 void        gnGrpSet_Opaque       (...);
 gnInt32_t   gnGrpGet_NodeSize     (...);
 gnInt32_t   gnGrpGet_LinkSize     (...);
 
 



 General Considerations:

 The memory area of type gnGrpGraph_s that holds a graph is always managed
 by the application. All dglib functions take as first argument a pointer
 to gnGrpGraph_s and use its internal data. The structure is not hidden
 and programs can access it, yet being highly reccomended to use hiders.

 It is responsability of the application to control the life cycle of a graph
 structure in the case it was malloced, gnGrpRelease() DOESN'T FREE IT BUT
 JUST CLEAN ITS INTERNALS.

 Keeping all data related to a graph into a stackable execution context
 helps in getting dglib thread-safe at multi-graph level. Nor global 
 neither static data delarations exist into dglib.
 At single-graph level multithread safety is so far provided for shortest
 path computations that can be parallelized.

 After a function has reported an error condition, diagnostic status
 can be obtained as an integer with gnGrpErrno() or in readable form with
 gnGrpStrerror().

 GRAPHS ARE VERSIONED, that is, they can be internally represented in different ways, depending
 on functional needs.

 Each version has its benefits and limits. So far version 2 and 3 are not yet implemented.
 The next is a list of some functions and there distribution between versions:


                                      1   2   3
-------------------------------------------------------
directed ............................ x   x   x
undirected .......................... -   -   x
in-degree nodes (reverse walk)....... -   x   -
out-degree nodes (straight walk)..... x   x   -
shortest-path ....................... x   x   x
reversed-shortest-path .............. -   x   -
depth-spanning ...................... x   x   x
breadth-spanning .................... x   x   x (version 1 not implemented)
depth-components .................... x   x   x
breadth-components .................. x   x   x (version 1 not implemented)
node-attributes ..................... x   x   x
link-attributes ..................... x   x   x
min-spanning ........................ x   x   x (version 1 not implemented)
TSP ................................. x   x   x (version 1 not implemented)


 As one can see, the main difference stays in the version 1 lacking in-degree support.
 A lot of applications don't need this functionality and keeping it out saves about 30% of
 memory.

 Although one should simulate a undirected graph by storing forward and backward links with
 same id and same costs into a directed graph, a proper undirected support will be implemented
 by version 3.

 Versions have also been founded in order to postpone hard design decision while minimizing impact
 on current development. There are two design drivers: GRASS and theory. Things needed by GRASS
 are implemented with high priority. As more users would follow, their requirements would be
 taken into account.

 GRASS doesn't actually make use of input output and graphs are always build 'on the fly' and
 destroyed after usage. The design idea behind the FLAT/TREE representation is:
 "read a graph and process it". This is why network analisys algorithms apply to FLAT graphs.




/*
 * FLAT DIRECTED GRAPH (FDG) MEMORY REPRESENTATION * VERSION 1:
 *
 * FDG is represented by two arrays of 32bit words: the node-buffer and the link-buffer
 *
 * Each node has a entry in the node-buffer.
 * Links (arcs connecting couples of nodes) are grouped in the link-buffer into link-areas, that is: all
 * links departing from a given node are kept continuos in a link-area.
 *
 * A node-entry has the fields:
 *  nodeid: a unique id for the node in the graph
 *  status: flags indicating the role of the node (from/to/both)
 *  offset: the byte offset to the link-area in the link-buffer
 *  [attr]: optionally an arbitrary length area for user supplied node attributes.
 *
 * A link-area has the fields:
 *  tocnt : the number of departing links
 *  toarr : the array of departing links
 *
 * Each link in the link-area array has the fields:
 *  offset: the byte offset in the node buffer of the destination node for this link
 *  cost  : the effort needed to 'travel' from origin node *to* the destination node (not bidirectional)
 *  user  : a value passed by the user for this link - it's usually a unique user supplied link-id.
 *  [attr]: optionally an arbitrary length area for user supplied link attributes.
 *
 * Nodes in the node buffer are kept sorted by ascending nodeid. Thus, given that a node entry has fixed size,
 * a node can be found using a binary search in the node buffer.
 * 
 * Node attributes are optionally stored by enlarging the node entry by a fixed amount of bytes (attr), as well as link
 * attributes, which are stored in the respective link entry extension (attr).
 * Sizes for node and link attributes are given at graph creation time and cannot be modified later on.
 * 
 *        +-------------------------------------------------------------------------------------------------------> ...
 *        | +---------------------------------------------------------------------+
 *        | | +-----------------------------------+                               |
 *        | | |                                   V                               V
 * Node Buffer   (nodeid|status|offset|attr)...  (nodeid|status|offset|attr)...  (nodeid|status|offset|attr)...
 *        | | |                   |                                                               |                     
 *        | | |   +---------------+                                      +------------------------+
 *        | | |   V                                                      V                              
 * Link Buffer   (tocnt|toarr) ...                                      (tocnt|toarr)                  
 *        | | |        (offset|cost|user|attr)[0]... ()[tocnt-1]...           (offset|cost|user|attr)[0]... ()[tocnt-1]...
 *        | | |           |                           |                         |                            ...
 *        | | +-----------+                           |                         |
 *        | +-----------------------------------------+                         |
 *        +---------------------------------------------------------------------+
 *
 */

/* FLAT DIRECTED GRAPH (FDG) FILE REPRESENTATION * VERSION 1
 *
 * FDGs can be stored into files as they are, or in other words, they are serializable.
 * Graphs are versioned: a pool exists of pointers to methods which implement a given graph version, for each graph version.
 * Actually only version 1 has been defined.
 * The version number is stored as the first byte of the graph file and must be supplied as an argument when we want to
 * initialize a new graph. When reading a graph from a stream, the library understands by the first byte what version
 * is it, and initializes it appropriately.
 *
 * Verion 1 graph file format:
 *
 * Field                          Size/Type                     Value range          Description
 * [VERSION...................]   1 byte                        1                    Version 1 graphs always keep value 1
 * [ENDIANESS.................]   1 byte                        1 | 2                Integer words byte order 1=big 2=little
 * [NODE ATTRIBUTES BYTE SIZE.]   4 bytes integer               >= 0                 Byte size of attributes area for each node
 * [LINK ATTRIBUTES BYTE SIZE.]   4 bytes integer               >= 0                 Byte size of attributes area for each link
 * [OPAQUE SET................]   16 words of 4 bytes           -                    Free user's storage
 * [NODE COUNT................]   4 bytes integer               > 0                  How many nodes in graph
 * [FROM NODE COUNT...........]   4 bytes integer               > 0                  How many nodes with from role
 * [TO NODE COUNT.............]   4 bytes integer               > 0                  How many nodes with to role
 * [ALONE NODE COUNT..........]   4 bytes integer               > 0                  How many nodes with alone role
 * [ARC (LINK) COUNT..........]   4 bytes integer               > 0                  Home many links in graph
 * [NODE BUFFER BYTE SIZE.....]   4 bytes integer               >= 0                 Byte size of the node buffer
 * [LINK BUFFER BYTE SIZE.....]   4 bytes integer               >= 0                 Byte size of the link buffer
 * [NODE BUFFER...............]   variable len array of bytes   V1 FDG NODE BUFFER   Node buffer
 * [LINK BUFFER...............]   variable len array of bytes   V1 FDG LINK BUFFER   Link buffer
 *
 */


