/* *
 * * Dglib (Directed Graph Library) aims at giving support to network analysis.
 * * Each graph is stored in a graph-context of type gnGrpGraph_s.
 * * At any given point in time a graph can be in one of three states: EMPTY, TREE, FLAT.
 * * We take a look of what these states mean:
 * *
 * * 1) EMPTY state
 * *    This is the state of a graph after initialization and before any network data
 * *	is put into it. In EMPTY state the only reasonable thing to do with the graph
 * *	is to add links (also called arcs) into it. This is done by gnGrpAddLink().
 * *	After the first link has been added the state of the graph changes to TREE.
 * *
 * * 2) TREE state
 * *	This is the state optimized to support graph modifications, since all data is
 * *	kept internally stored in binary search trees. The operations that can be performed
 * *	on a TREE graph are:
 * *	- gnGrpAddLink() - add links;
 * *	- gnGrpFlatten() - convert the graph to FLAT state;
 * *	- gnGrp{Set|Get}NodeAttr() - set/get extended attributes for a node;
 * *	- gnGrp{Set|Get}LinkAttr() - set/get extended attributes for a link;
 * *	- gnGrpGetNode() - return pointer to a node
 * *	- gnGrpGetLinkArea() - return pointer to a link-area 
 * *	- gnGrpGetLink() - return pointer to a link
 * *	- gnGrpRelease() - release graph's resources.
 * *
 * * 3) FLAT state
 * *	In this state the graph is 'serializable', which is: it can be written to
 * *	a file or a stream. The binaru tree data representation is
 * *	transformed into arrays of 32 bit words with pointers stored as offsets.
 * *	Network analysis functions apply to FLAT state graphs. When a FLAT graph is
 * *	read from a file or stream it is ready for analisys with no further initialization.
 * *	The operations that can be performed on a FLAT graph are:
 * *	- gnGrpUnflatten() - convert the graph back to TREE state;
 * *	- gnGrpWrite() - write the graph to a user supplied file descriptor;
 * *	- gnGrpRead() - read the graph from a user supplied file descriptor;
 * *	- gnGrp{Set|Get}NodeAttr() - set/get extended attributes for a node;
 * *	- gnGrp{Set|Get}LinkAttr() - set/get extended attributes for a link;
 * *	- gnGrpShortestPath() - perform a shortest path search;
 * *	- gnGrpGetNode() - return pointer to a node
 * *	- gnGrpGetLinkArea() - return pointer to a link-area 
 * *	- gnGrpGetLink() - return pointer to a link
 * *	- gnGrpRelease() - discard the graph.
 * *
 * * Considerations:
 * * The memory area of type gnGrpGraph_s that holds a graph is always handled
 * * by the application. All dglib functions take as first argument a pointer
 * * to gnGrpGraph_s and use its internal data. The structure is not hidden
 * * and programs can access it. It is responsability of the application to
 * * control the life cycle of a graph structure in the case it was malloced,
 * * gnGrpRelease() doesn't free it but just clean its internals.
 * * Keeping all data related to a graph into a stackable execution context
 * * helps in getting dglib thread-safe at multi-graph level. Nor global 
 * * neither static data delarations exist into dglib.
 * * At single-graph level multhread safety is so far provided for shortest
 * * path computations that can be parallelized.
 * * After a function has reported an error condition, diagnostic status
 * * can be obtained as an integer with gnGrpErrno() or in readable form with
 * * gnGrpStrerror().
 * *
 * * API functions:
 * *
 * * In order to initialize a new EMPTY graph use:
 * *
 * * int gnGrpInitialize(
 * *					gnGrpGraph_s *		pgraph ,
 * *					gnByte_t 			Version ,
 * *					gnInt32_t			NodeAttrSize ,
 * *					gnInt32_t			LinkAttrSize ,
 * *					gnInt32_t * 		pOpaqueSet
 * *					);
 * *
 * * 'pgraph'       pointer to the user supplied graph context
 * * 'Version'      is always 1;
 * * 'NodeAttrSize' defines how many bytes to keep for each node attributes, if one
 * *                doesn't plan to use node attributes then 0 must be given;
 * * 'LinkAttrSize' defines how many bytes to keep for each link attrubutes, if one
 * *                doesn't plan to use link attributes then 0 must be given;
 * * 'pOpaqueSet'   is the pointer to a user supplied array of 16 32bit words that comes
 * *                stored with the graph and that can be used to save user's graph properties.
 * *
 * * Initialization is implicit when reading an existing graph from a source.
 * *
 * * In order to add links on a EMPTY or TREE graph we use:
 * * 
 * * int 				gnGrpAddLink(
 * * 								gnGrpGraph_s * 		pgraph ,
 * * 								gnInt32_t 			lFrom ,
 * * 								gnInt32_t 			lTo ,
 * * 								gnInt32_t 			lCost ,
 * * 								gnInt32_t 			lUser
 * * 								void *				pvFnodeAttr ,
 * * 								void *				pvTnodeAttr ,
 * * 								void *				pvLinkAttr
 * * 								);
 * * 
 * * 'pgraph'       pointer to the user supplied graph context
 * * 'lFrom'        the node-id of the from node
 * * 'lTo'          the node-id of the to node (this couple of values defines an intrinsic arc direction).
 * * 'lCost'        the cost to travel from/to in user defined units.
 * * 'lUser'        a user assigned attribute assigned to this link, it's usually a unique identifier for
 * *                the link. 
 * * 'pvFnodeAttr'  user supplied from-node extended attributes. The supplied memory size must
 * *                match the NodeAttrSize used the first time to initialize the graph.
 * * 'pvFnodeAttr'  user supplied to-node extended attributes. The supplied memory size must
 * *                match the NodeAttrSize used the first time to initialize the graph.
 * * 'pvFnodeAttr'  user supplied link extended attributes. The supplied memory size must
 * *                match the LinkAttrSize used the first time to initialize the graph.
 * *
 * * Nodes cannot be added alone, but only as part of an arc.
 * *
 * * We have two ways for assigning extended attributes to nodes and links: 1) pass attribute data as last
 * * three gnGrpAddLink parameters; 2) use gnGrpSetNodeAttr() and gnGrpSetLinkAttr() respectively.
 * * 
 * * int gnGrpSetNodeAttr	(
 * * 						gnGrpGraph_s * pgraph ,
 * * 						void * pattr ,
 * * 						gnInt32_t nodeid
 * * 						);
 * *
 * * 'pgraph'       pointer to the user supplied graph context
 * * 'pattr'        user supplied node extended attributes. The supplied memory size must
 * *                match the NodeAttrSize used the first time to initialize the graph.
 * * 'nodeid'		the recipient node identifier. The node must already exist in the graph.
 * * 
 * *
 * * To convert a TREE graph to FLAT state we use:
 * *
 * * int gnGrpFlatten	(
 * * 					gnGrpGraph_s * 	pgraph
 * * 					);
 * * 
 * * After flattening we can serialize it to a file descriptor:
 * *
 * * int gnGrpWrite		(
 * * 					gnGrpGraph_s * 	pgraph,
 * * 					int 			fd
 * * 					);
 * *
 * * In order to release resources reserved by a graph we use:
 * *
 * * int gnGrpRelease	(
 * *					gnGrpGraph_s * 	pgraph
 * *					);
 * * 
 * *
 * * When we want to read a FLAT graph we use:
 * *
 * *
 * * int gnGrpRead	(
 * *				gnGrpGraph_s *  pgraph,
 * *				int 			fd
 * *				);
 * *
 * * In this case no gnGrpInitialize() is needed on pgraph.
 * *
 * * The only network analysis function so far supported is:
 * *
 * * gnGrpSPReport_s *	gnGrpDijkstra	(
 * * 									gnGrpGraph_s * 	pgraph ,
 * * 			 						gnInt32_t 		from ,
 * * 			 						gnInt32_t 		to ,
 * * 			 						int (*clip)	(
 * * 												gnGrpGraph_s * 	pgraph ,
 * * 												gnInt32_t * 	pprevlink ,
 * * 												gnInt32_t * 	pnodefrom ,
 * * 												gnInt32_t * 	plink ,
 * * 												gnInt32_t * 	pnodeto ,
 * * 												gnInt32_t * 	pcost ,
 * * 												void * 			pvarg
 * * 												) ,
 * * 			 						void * 			pvcliparg
 * * 			 						);
 * * 
 * * 'pgraph'       pointer to the user supplied graph context
 * * 'from'         start node identifier
 * * 'to'           arrival node identifier
 * * 'clip'         user supplied clipping function, see below - can be a NULL pointer
 * * 'pvcliparg'    user supplied parameter, passed back to clip as pvarg - can be a NULL pointer
 * * 
 * */

/*
 * FLAT DIRECTED GRAPH (FDG) MEMORY REPRESENTATION * VERSION 1:
 *
 * FDG is represented by two arrays of 32bit words: the node-buffer and the link-buffer
 *
 * Each node has a entry in the node-buffer.
 * Links (arcs connecting couples of nodes) are grouped in the link-buffer into link-areas, that is: all
 * links departing from a given node are kept continuos in a link-area.
 *
 * A node-entry has the fields:
 *  nodeid: a unique id for the node in the graph
 *  status: flags indicating the role of the node (from/to/both)
 *  offset: the byte offset to the link-area in the link-buffer
 *  [attr]: optionally an arbitrary length area for user supplied node attributes.
 *
 * A link-area has the fields:
 *  tocnt : the number of departing links
 *  toarr : the array of departing links
 *
 * Each link in the link-area array has the fields:
 *  offset: the byte offset in the node buffer of the destination node for this link
 *  cost  : the effort needed to 'travel' from origin node *to* the destination node (not bidirectional)
 *  user  : a value passed by the user for this link - it's usually a unique user supplied link-id.
 *  [attr]: optionally an arbitrary length area for user supplied link attributes.
 *
 * Nodes in the node buffer are kept sorted by ascending nodeid. Thus, given that a node entry has fixed size,
 * a node can be found using a binary search in the node buffer.
 * 
 * Node attributes are optionally stored by enlarging the node entry by a fixed amount of bytes (attr), as well as link
 * attributes, which are stored in the respective link entry extension (attr).
 * Sizes for node and link attributes are given at graph creation time and cannot be modified later on.
 * 
 *        +-------------------------------------------------------------------------------------------------------> ...
 *        | +---------------------------------------------------------------------+
 *        | | +-----------------------------------+                               |
 *        | | |                                   V                               V
 * Node Buffer   (nodeid|status|offset|attr)...  (nodeid|status|offset|attr)...  (nodeid|status|offset|attr)...
 *        | | |                   |                                                               |                     
 *        | | |   +---------------+                                      +------------------------+
 *        | | |   V                                                      V                              
 * Link Buffer   (tocnt|toarr) ...                                      (tocnt|toarr)                  
 *        | | |        (offset|cost|user|attr)[0]... ()[tocnt-1]...           (offset|cost|user|attr)[0]... ()[tocnt-1]...
 *        | | |           |                           |                         |                            ...
 *        | | +-----------+                           |                         |
 *        | +-----------------------------------------+                         |
 *        +---------------------------------------------------------------------+
 *
 */

/* FLAT DIRECTED GRAPH (FDG) FILE REPRESENTATION * VERSION 1
 *
 * FDGs can be stored into files as they are, or in other words, they are serializable.
 * Graphs are versioned: a pool exists of pointers to methods which implement a given graph version, for each graph version.
 * Actually only version 1 has been defined.
 * The version number is stored as the first byte of the graph file and must be supplied as an argument when we want to
 * initialize a new graph. When reading a graph from a stream, the library understands by the first byte what version
 * is it, and initializes it appropriately.
 *
 * Verion 1 graph file format:
 *
 * Field                          Size/Type                     Value range          Description
 * [VERSION...................]   1 byte                        1                    Version 1 graphs always keep value 1
 * [ENDIANESS.................]   1 byte                        1 | 2                Integer words byte order 1=big 2=little
 * [NODE ATTRIBUTES BYTE SIZE.]   4 bytes integer               >= 0                 Byte size of attributes area for each node
 * [LINK ATTRIBUTES BYTE SIZE.]   4 bytes integer               >= 0                 Byte size of attributes area for each link
 * [OPAQUE SET................]   16 words of 4 bytes           -                    Free user's storage
 * [NODE COUNT................]   4 bytes integer               > 0                  How many nodes in graph
 * [FROM NODE COUNT...........]   4 bytes integer               > 0                  How many nodes with from role
 * [TO NODE COUNT.............]   4 bytes integer               > 0                  How many nodes with to role
 * [ARC (LINK) COUNT..........]   4 bytes integer               > 0                  Home many links in graph
 * [NODE BUFFER BYTE SIZE.....]   4 bytes integer               >= 0                 Byte size of the node buffer
 * [LINK BUFFER BYTE SIZE.....]   4 bytes integer               >= 0                 Byte size of the link buffer
 * [NODE BUFFER...............]   variable len array of bytes   V1 FDG NODE BUFFER   Node buffer
 * [LINK BUFFER...............]   variable len array of bytes   V1 FDG LINK BUFFER   Link buffer
 *
 */


